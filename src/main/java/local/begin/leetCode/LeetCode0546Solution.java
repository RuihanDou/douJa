package local.begin.leetCode;


/**
 * 546. 移除盒子
 * 给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。
 *
 * 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。
 *
 * 返回 你能获得的最大积分和 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：boxes = [1,3,2,2,2,3,4,3,1]
 * 输出：23
 * 解释：
 * [1, 3, 2, 2, 2, 3, 4, 3, 1]
 * ----> [1, 3, 3, 4, 3, 1] (3*3=9 分)
 * ----> [1, 3, 3, 3, 1] (1*1=1 分)
 * ----> [1, 1] (3*3=9 分)
 * ----> [] (2*2=4 分)
 * 示例 2：
 *
 * 输入：boxes = [1,1,1]
 * 输出：9
 * 示例 3：
 *
 * 输入：boxes = [1]
 * 输出：1
 *
 *
 * 提示：
 *
 * 1 <= boxes.length <= 100
 * 1 <= boxes[i] <= 100
 */
public class LeetCode0546Solution {

    /**
     * 用 f(l,r,k) 表示移除区间 [l,r] 的元素 a_l, a_(l + 1), a_(l + 2), ... , a_r 加上该区间右边等于 a_r 的 k 个元素组成序列的最大积分
     * 例如序列 {6,3,6,5,6,7,6,6,8,6}，l=0，r=4，那么 f(l,r,3) 对应的元素就是 {[6_,3_,6_,5_,6_],7,6_,6_,8,6_} 中标记下划线的部分。
     *
     * @param boxes
     * @return
     */
//    public int removeBoxes(int[] boxes) {
//
//    }

}
